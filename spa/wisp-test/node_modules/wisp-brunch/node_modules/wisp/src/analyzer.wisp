(import [symbol symbol? keyword?] "./ast")
(import [seq? seq conj map every? interleave] "./sequence")
(import [vector? dictionary? string? keys vals =] "./runtime")

(defn analyze-symbol
  "Finds the var associated with sym"
  [env form]
  (let [result {:env env :form form}
        locals (:locals env)
        binding (get locals form)]
    (conj result {:op :var
                  :info (if binding
                          binding
                          (resolve-existing-var env sym))})))

(defn analyze-keyword
  [env sym]
  ;; When not at the REPL, *ns-sym* is not set so the reader did not
  ;; know the namespace of the keyword
  (let [form (if (= (namespace form) (name *reader-ns-name*))
               (keyword (name (:name (:ns env))) (name form))
               form)]
    {:op :constant :env env :form form}))

(defn analyze-dictionary
  [env form name]
  (let [expr-env (assoc env :context :expr)
        simple-keys? (every? #(or (string? %) (keyword? %)) (keys form))
        ks (disallowing-recur (vec (map #(analyze expr-env % name) (keys form))))
        vs (disallowing-recur (vec (map #(analyze expr-env % name) (vals form))))]
    (analyze-wrap-meta {:op :map :env env :form form
                        :keys ks :vals vs :simple-keys? simple-keys?
                        :children (vec (interleave ks vs))}
                       name)))

(defn analyze-vector
  [env form name]
  (let [expr-env (conj env {:context :expr})
        items (disallowing-recur (vec (map #(analyze expr-env % name) form)))]
    (analyze-wrap-meta {:op :vector :env env :form form :items items :children items} name)))


(defn analyze
  "Given an environment, a map containing {:locals (mapping of names to bindings), :context
  (one of :statement, :expr, :return), :ns (a symbol naming the
  compilation ns)}, and form, returns an expression object (a map
  containing at least :form, :op and :env keys). If expr has any (immediately)
  nested exprs, must have :children [exprs...] entry. This will
  facilitate code walking without knowing the details of the op set."
  ([env form] (analyze env form nil))
  ([env form name]
   ;; (load-core) TODO: Find out what that's for
   (cond
    (symbol? form) (analyze-symbol env form)
    (keyword? form) (analyze-keyword env form)
    (and (seq? form) (seq form)) (analyze-seq env form name)
    ;(map? form) (analyze-map env form name)
    (dictionary? form) (analyze-dictionary env form name)
    (vector? form) (analyze-vector env form name)
    ;(set? form) (analyze-set env form name)

    :else {:op :constant :env env :form form})))