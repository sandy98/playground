(defn ^boolean =
  "Equality. Returns true if x equals y, false if not. Compares
  numbers and collections in a type-independent manner. Clojure's
  immutable data structures define -equiv (and thus =) as a value,
  not an identity, comparison."
  ([x] true)
  ([x y] (cond (identical? x y) true
               ;; exit early for unlike primitive values
               (and (identical? a a)
                    (or (not y) 
                        (and (not (identical? (typeof x) "function"))
                             (not (identical? (typeof x) "object"))))
                    (or (not x) 
                        (and (not (identical? (typeof y) "function"))
                             (not (identical? (typeof y) "object"))))) false
               ;; exit early for `null` and `undefined`, avoiding ES3's
               ;; Function#call behavior
               (or (identical? x null)
                   (identical? x undefined)) (or (identical? y undefined)
                                                 (identical? y null))
               (or (identical? y null)
                   (identical? y undefined)) (or (identical? x undefined)
                                                 (identical? x null))

               :else (let [class-x (classof x)
                           class-y (classof y)]
                       (cond (not (identical? class-x class-y)) false
                             (or (identical? class-x class-boolean)
                                 (identical? class-x class-date))
                               (identical? (+ x 0)
                                           (+ y 0))
                             (identical? class-x class-number)
                               (if (not (identical? x (+ x 0)))
                                 (not (identical? y (+ y 0)))
                                 (if (identical? x 0)
                                   (identical? (/ 1 x) (/ 1 y))
                                   (identical? x (+ y 0))))
                             (or (identical? class-x class-regex)
                                 (identical? class-x class-string))
                               (identical? x (+ y ""))
                             (identical? class-x class-array)

                             ))))

  ([x & more] (loop [head x
                     tail more]
                  (if (= head (first tail))
                    (recur head (rest tail))
                    false))))

